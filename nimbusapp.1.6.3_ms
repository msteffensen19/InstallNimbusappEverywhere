#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/Slurp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP';
  package File::Slurp;
  use strict;
  use warnings ;
  our $VERSION = '9999.32';
  $VERSION = eval $VERSION;
  use Carp ;
  use Exporter qw(import);
  use Fcntl qw( :DEFAULT ) ;
  use File::Basename ();
  use File::Spec;
  use File::Temp qw(tempfile);
  use IO::Handle ();
  use POSIX qw( :fcntl_h ) ;
  use Errno ;
  my @std_export = qw(
  	read_file
  	write_file
  	overwrite_file
  	append_file
  	read_dir
  ) ;
  my @edit_export = qw(
  	edit_file
  	edit_file_lines
  ) ;
  my @abbrev_export = qw(
  	rf
  	wf
  	ef
  	efl
  ) ;
  our @EXPORT_OK = (
  	@edit_export,
  	@abbrev_export,
  	qw(
  		slurp
  		prepend_file
  	),
  ) ;
  our %EXPORT_TAGS = (
  	'all'	=> [ @std_export, @edit_export, @abbrev_export, @EXPORT_OK ],
  	'edit'	=> [ @edit_export ],
  	'std'	=> [ @std_export ],
  	'abr'	=> [ @abbrev_export ],
  ) ;
  our @EXPORT = @std_export ;
  my $max_fast_slurp_size = 1024 * 100 ;
  my $is_win32 = $^O =~ /win32/i ;
  *slurp = \&read_file ;
  *rf = \&read_file ;
  sub read_file {
  	my $file_name = shift;
  	my $opts = (ref $_[0] eq 'HASH') ? shift : {@_};
  	if (ref($file_name)) {
  		my $ref_result = _check_ref($file_name, $opts);
  		if (ref($ref_result)) {
  			@_ = ($opts, $ref_result);
  			goto &_error;
  		}
  		$file_name = $ref_result if $ref_result;
  	}
  	my $fh;
  	if (ref($file_name)) {
  		$fh = $file_name;
  	}
  	else {
  		unless (open $fh, "<:raw", $file_name) {
  			@_ = ($opts, "read_file '$file_name' - open: $!");
  			goto &_error;
  		}
  		if (my $bm = $opts->{binmode}) {
  			binmode $fh, $bm;
  		}
  	}
  	my $buf;
  	my $buf_ref = $opts->{buf_ref} || \$buf;
  	${$buf_ref} = '';
  	my $blk_size = $opts->{blk_size} || 1024 * 1024;
  	if (my $size = -f $fh && -s _) {
  		$blk_size = $size if $size < $blk_size;
  		my ($pos, $read) = 0;
  		do {
  			unless(defined($read = read $fh, ${$buf_ref}, $blk_size, $pos)) {
  				@_ = ($opts, "read_file '$file_name' - read: $!");
  				goto &_error;
  			}
  			$pos += $read;
  		} while ($read && $pos < $size);
  	}
  	else {
  		${$buf_ref} = do { local $/; <$fh> };
  	}
  	seek($fh, $opts->{_data_tell}, SEEK_SET) if $opts->{_is_data} && $opts->{_data_tell};
  	${$buf_ref} =~ s/\015\012/\012/g if ${$buf_ref} && $is_win32 && !$opts->{binmode};
  	my $want_array = wantarray; # let's only ask for this once
  	if ($want_array || $opts->{array_ref}) {
  		use re 'taint';
  		my $sep = $/;
  		$sep = '\n\n+' if defined $sep && $sep eq '';
  		my @lines = length(${$buf_ref}) ?
  			${$buf_ref} =~ /(.*?$sep|.+)/sg : ();
  		chomp @lines if $opts->{chomp};
  		return \@lines if $opts->{array_ref};
  		return @lines;
  	}
  	return $buf_ref if $opts->{scalar_ref};
  	return ${$buf_ref} if defined $want_array;
  	return;
  }
  sub _check_ref {
  	my( $handle, $opts ) = @_ ;
  	if ( eval { $handle->isa( 'GLOB' ) || $handle->isa( 'IO' ) } ) {
  		my $err = _seek_data_handle( $handle, $opts ) ;
  		return \$err if $err ;
  		return ;
  	}
  	eval { require overload } ;
  	return \"Bad handle '$handle' is not a GLOB or IO object or overloaded"
  		 if $@ || !overload::Overloaded( $handle ) ;
  	return "$handle" ;
  }
  sub _seek_data_handle {
  	my( $handle, $opts ) = @_ ;
  	$opts->{_is_data} = 0;
  	$opts->{_data_tell} = 0;
  	eval{ require B } ;
  	if ( $@ ) {
  		return <<ERR ;
  Can't find B.pm with this Perl: $!.
  That module is needed to properly slurp the DATA handle.
  ERR
  	}
  	if ( B::svref_2object( $handle )->IO->IoFLAGS & 16 ) {
  		$opts->{_is_data} = 1;
  		$opts->{_data_tell} = tell($handle);
  	}
  	return ;
  }
  *wf = \&write_file ;
  sub write_file {
  	my $file_name = shift;
  	my $opts = (ref $_[0] eq 'HASH') ? shift : {};
  	my $fh;
  	my $no_truncate = 0;
  	my $orig_filename;
  	if (ref($file_name)) {
  		my $ref_result = _check_ref($file_name, $opts);
  		if (ref($ref_result)) {
  			@_ = ($opts, $ref_result);
  			goto &_error;
  		}
  		if ($ref_result) {
  			$file_name = $ref_result;
  		}
  		else {
  			$fh = $file_name;
  			$no_truncate = 1;
  			delete $opts->{atomic};
  			delete $opts->{perms};
  		}
  	}
  	unless ($fh) {
  		$orig_filename = $file_name;
  		my $perms = defined($opts->{perms}) ? $opts->{perms} : 0666;
  		my $mode = O_WRONLY | O_CREAT;
  		$mode |= O_APPEND if $opts->{append};
  		$mode |= O_EXCL if $opts->{no_clobber};
  		if ($opts->{atomic}) {
  			my $dir = File::Spec->rel2abs(File::Basename::dirname($file_name));
  			if (!defined($opts->{perms}) && -e $file_name && -f _) {
  				$perms = 07777 & (stat $file_name)[2];
  			}
  			{
  				local $^W = 0; # AYFKM
  				(undef, $file_name) = tempfile('.tempXXXXX', DIR => $dir, OPEN => 0);
  			}
  		}
  		$fh = local *FH;
  		unless (sysopen($fh, $file_name, $mode, $perms)) {
  			@_ = ($opts, "write_file '$file_name' - sysopen: $!");
  			goto &_error;
  		}
  	}
  	if (my $binmode = $opts->{binmode}) {
  		binmode($fh, $binmode);
  	}
  	my $buf_ref;
  	my $data_is_ref = 0;
  	if (ref($opts->{buf_ref}) eq 'SCALAR') {
  		$buf_ref = $opts->{buf_ref};
  		$data_is_ref = 1;
  	}
  	elsif (ref($_[0]) eq 'SCALAR') {
  		$buf_ref = shift;
  		$data_is_ref = 1;
  	}
  	elsif (ref($_[0]) eq 'ARRAY') {
  		${$buf_ref} = join '', @{$_[0]};
  	}
  	else {
  		${$buf_ref} = join '', @_;
  	}
  	seek($fh, 0, SEEK_END) if $opts->{append};
  	print {$fh} ${$buf_ref};
  	truncate($fh, tell($fh)) unless $no_truncate;
  	close($fh);
  	if ($opts->{atomic} && !rename($file_name, $orig_filename)) {
  		@_ = ($opts, "write_file '$file_name' - rename: $!");
  		goto &_error;
  	}
  	return 1;
  }
  *overwrite_file = \&write_file ;
  sub append_file {
  	my $opts = $_[1] ;
  	if ( ref $opts eq 'HASH' ) {
  		$opts->{append} = 1 ;
  	}
  	else {
  		splice( @_, 1, 0, { append => 1 } ) ;
  	}
  	goto &write_file
  }
  sub prepend_file {
  	my $file_name = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  	delete @{$opts}{@bad_opts} ;
  	my $prepend_data = shift ;
  	$prepend_data = '' unless defined $prepend_data ;
  	$prepend_data = ${$prepend_data} if ref $prepend_data eq 'SCALAR' ;
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ scalar_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts,
  		       $prepend_data, $$existing_data ) ;
  	} ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  	return $write_result ;
  }
  *ef = \&edit_file ;
  sub edit_file(&$;$) {
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  	delete @{$opts}{@bad_opts} ;
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ scalar_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  	my( $edited_data ) = map { $edit_code->(); $_ } $$existing_data ;
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, $edited_data ) } ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  	return $write_result ;
  }
  *efl = \&edit_file_lines ;
  sub edit_file_lines(&$;$) {
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  	delete @{$opts}{@bad_opts} ;
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ array_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  	my @edited_data = map { $edit_code->(); $_ } @$existing_data ;
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, @edited_data ) } ;
  	if ( $@ ) {
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  	return $write_result ;
  }
  sub read_dir {
  	my $dir = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  	local(*DIRH);
  	unless ( opendir( DIRH, $dir ) ) {
  		@_ = ( $opts, "read_dir '$dir' - opendir: $!" ) ;
  		goto &_error ;
  	}
  	my @dir_entries = readdir(DIRH) ;
  	@dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
  		unless $opts->{'keep_dot_dot'} ;
  	if ( $opts->{'prefix'} ) {
  		$_ = File::Spec->catfile($dir, $_) for @dir_entries;
  	}
  	return @dir_entries if wantarray ;
  	return \@dir_entries ;
  }
  my %err_func = (
  	'carp'	=> \&carp,
  	'croak'	=> \&croak,
  ) ;
  sub _error {
  	my( $opts, $err_msg ) = @_ ;
   	my $func = $err_func{ $opts->{'err_mode'} || 'croak' } ;
  	return unless $func ;
  	$func->($err_msg) if $func ;
  	return undef ;
  }
  1;
FILE_SLURP

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;
  use strict;
  use warnings;
  our $VERSION = '0.043'; # VERSION
  use Carp ();
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy timeout
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  sub new {
      my($class, %args) = @_;
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
      bless $self, $class;
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
      $self->_set_proxies;
      return $self;
  }
  sub _set_proxies {
      my ($self) = @_;
      if (! $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
          if ( defined $self->{proxy} ) {
              $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
          }
          else {
              delete $self->{proxy};
          }
      }
      if (! $self->{http_proxy} ) {
          $self->{http_proxy} = $ENV{http_proxy} || $self->{proxy};
          if ( defined $self->{http_proxy} ) {
              $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
              $self->{_has_proxy}{http} = 1;
          }
          else {
              delete $self->{http_proxy};
          }
      }
      if (! $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
          if ( $self->{https_proxy} ) {
              $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
              $self->{_has_proxy}{https} = 1;
          }
          else {
              delete $self->{https_proxy};
          }
      }
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
      return;
  }
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
      if (my $e = $@) {
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . ($class->VERSION || 0);
  }
  sub _request {
      my ($self, $method, $url, $args) = @_;
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port );
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      if ( my @redir_args = $self->_maybe_redirect($request, $response, $args) ) {
          $handle->close;
          return $self->_request(@redir_args, $args);
      }
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          $known_message_length = 1;
      }
      else {
          my $data_cb = $self->_prepare_data_cb($response, $args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
      return $response;
  }
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port) = @_;
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port);
      }
  }
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
      $handle->connect($p_scheme, $p_host, $p_port);
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
      return $handle;
  }
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
      return ($scheme, $host, $port, $auth);
  }
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
      $handle->_assert_ssl;
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
      my $connect_request = {
          method    => 'CONNECT',
          uri       => $request->{host_port},
          headers   => {
              host => $request->{host_port},
              'user-agent' => $agent,
          }
      };
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
      $handle->start_ssl( $request->{host} );
      return;
  }
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
          }
      }
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
      return;
  }
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
      my @cookies = ref $cookies ? @$cookies : $cookies;
      $self->cookie_jar->add( $url, $_ ) for @cookies;
      return;
  }
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
      return;
  }
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      if (($status eq '303' or ($status =~ /^30[127]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and ++$args->{redirects} <= $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  sub _split_url {
      my $url = pop;
      my ($scheme, $authority, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
      my ($auth,$host);
      $authority = (length($authority)) ? $authority : 'localhost';
      if ( $authority =~ /@/ ) {
          ($auth,$host) = $authority =~ m/\A([^@]*)@(.*)\z/;   # user:pass@host
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      else {
          $host = $authority;
          $auth = '';
      }
      $host = lc $host;
      my $port = do {
         $host =~ s/:([0-9]*)\z// && length $1
           ? $1
           : ($scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef);
      };
      return ($scheme, $host, $port, $path_query, $auth);
  }
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  sub BUFSIZE () { 32768 } ## no critic
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  sub connect {
      @_ == 4 || die(q/Usage: $handle->connect(scheme, host, port)/ . "\n");
      my ($self, $scheme, $host, $port) = @_;
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $host,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
          KeepAlive => !!$self->{keep_alive}
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
      $self->start_ssl($host) if $scheme eq 'https';
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{port} = $port;
      return $self;
  }
  sub start_ssl {
      my ($self, $host) = @_;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
      my $len = length $buf;
      my $off = 0;
      local $SIG{PIPE} = 'IGNORE';
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
          }
      }
      return $off;
  }
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
      my $buf  = '';
      my $got = length $self->{rbuf};
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
      while () {
           my $line = $self->readline;
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  my %HeaderCase = (
      'content-md5'      => 'Content-MD5',
      'etag'             => 'ETag',
      'te'               => 'TE',
      'www-authenticate' => 'WWW-Authenticate',
      'x-xss-protection' => 'X-XSS-Protection',
  );
  sub write_header_lines {
      (@_ == 2 || @_ == 3 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers[,prefix])/ . "\n");
      my($self, $headers, $prefix_data) = @_;
      my $buf = (defined $prefix_data ? $prefix_data : '');
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $field_name =~ s/\b(\w)/\u$1/g;
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              /[^\x0D\x0A]/
                or die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n");
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
      return;
  }
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
          defined $data && length $data
            or last;
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
          $len += $self->write($data);
      }
      $len == $content_length
        or die(qq/Content-Length missmatch (got: $len expected: $content_length)\n/);
      return $len;
  }
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
      while () {
          my $head = $self->readline;
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
          my $len = hex($1)
            or last;
          $self->read_content_body($cb, $response, $len);
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
          defined $data && length $data
            or last;
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
          $len += length $data;
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
      my $line = $self->readline;
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  sub write_request_header {
      @_ == 4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ . "\n");
      my ($self, $method, $request_uri, $headers) = @_;
      return $self->write_header_lines($headers, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
      vec(my $fdset = '', $fd, 1) = 1;
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  sub _assert_ssl {
      die(qq/IO::Socket::SSL 1.42 must be installed for https support\n/)
          unless eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)};
      die(qq/Net::SSLeay 1.49 must be installed for https support\n/)
          unless eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)};
  }
  sub can_reuse {
      my ($self,$scheme,$host,$port) = @_;
      return 0 if
           length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  sub _find_CA_file {
      my $self = shift();
      return $self->{SSL_options}->{SSL_ca_file}
          if $self->{SSL_options}->{SSL_ca_file} and -e $self->{SSL_options}->{SSL_ca_file};
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA };
      foreach my $ca_bundle (qw{
          /etc/ssl/certs/ca-certificates.crt
          /etc/pki/tls/certs/ca-bundle.crt
          /etc/ssl/ca-bundle.pem
          }
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  sub _ssl_args {
      my ($self, $host) = @_;
      my %ssl_args;
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
      return \%ssl_args;
  }
  1;
HTTP_TINY

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  use B;
  our $VERSION = '0.58';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  sub false () {$FALSE}  ## no critic (prototypes)
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  sub to_json { _encode_value(shift) }
  sub true () {$TRUE} ## no critic (prototypes)
  sub _decode {
    my $valueref = shift;
    eval {
      die "Missing or empty input\n" unless length( local $_ = shift );
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
      $$valueref = _decode_value();
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
    return $@;
  }
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
      push @array, _decode_value();
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
      _throw('Expected comma or right square bracket while parsing array');
    }
    return \@array;
  }
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
      my $key = _decode_string();
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
      $hash{$key} = _decode_value();
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
      _throw('Expected comma or right curly bracket while parsing object');
    }
    return \%hash;
  }
  sub _decode_string {
    my $pos = pos;
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
      if ($2) { $buffer .= $ESCAPE{$2} }
      else {
        my $ord = hex $3;
        if (($ord & 0xf800) == 0xd800) {
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
        $buffer .= pack 'U', $ord;
      }
    }
    return $buffer . substr $str, pos $str, length $str;
  }
  sub _decode_value {
    m/\G[\x20\x09\x0a\x0d]*/gc;
    return _decode_string() if m/\G"/gc;
    return _decode_object() if m/\G\{/gc;
    return _decode_array() if m/\G\[/gc;
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
    return $TRUE if m/\Gtrue/gc;
    return $FALSE if m/\Gfalse/gc;
    return undef if m/\Gnull/gc;  ## no critic (return)
    _throw('Expected string, array, object, number, boolean or null');
  }
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  sub _encode_value {
    my $value = shift;
    if (my $ref = ref $value) {
      return _encode_object($value) if $ref eq 'HASH';
      return _encode_array($value) if $ref eq 'ARRAY';
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
    return 'null' unless defined $value;
    return $value
      if B::svref_2object(\$value)->FLAGS & (B::SVp_IOK | B::SVp_NOK)
      && 0 + $value eq $value
      && $value * 0 == 0;
    return _encode_string($value);
  }
  sub _throw {
    m/\G[\x20\x09\x0a\x0d]*/gc;
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
    die "$context\n";
  }
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"Sort/Versions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SORT_VERSIONS';
  package Sort::Versions;
  $Sort::Versions::VERSION = '1.62';
  use 5.006;
  use strict;
  use warnings;
  require Exporter;
  our @ISA        = qw(Exporter);
  our @EXPORT     = qw(&versions &versioncmp);
  our @EXPORT_OK  = qw();
  sub versioncmp ($$) {
      my @A = ($_[0] =~ /([-.]|\d+|[^-.\d]+)/g);
      my @B = ($_[1] =~ /([-.]|\d+|[^-.\d]+)/g);
      my ($A, $B);
      while (@A and @B) {
  	$A = shift @A;
  	$B = shift @B;
  	if ($A eq '-' and $B eq '-') {
  	    next;
  	} elsif ( $A eq '-' ) {
  	    return -1;
  	} elsif ( $B eq '-') {
  	    return 1;
  	} elsif ($A eq '.' and $B eq '.') {
  	    next;
  	} elsif ( $A eq '.' ) {
  	    return -1;
  	} elsif ( $B eq '.' ) {
  	    return 1;
  	} elsif ($A =~ /^\d+$/ and $B =~ /^\d+$/) {
  	    if ($A =~ /^0/ || $B =~ /^0/) {
  		return $A cmp $B if $A cmp $B;
  	    } else {
  		return $A <=> $B if $A <=> $B;
  	    }
  	} else {
  	    $A = uc $A;
  	    $B = uc $B;
  	    return $A cmp $B if $A cmp $B;
  	}	
      }
      @A <=> @B;
  }
  sub versions () {
      my $callerpkg = (caller)[0];
      my $caller_a = "${callerpkg}::a";
      my $caller_b = "${callerpkg}::b";
      no strict 'refs';
      return versioncmp($$caller_a, $$caller_b);
  }
  1;
SORT_VERSIONS

$fatpacked{"Template/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEMPLATE_TINY';
  package Template::Tiny; # git description: v1.13-3-g7fb3b0a
  use strict;
  our $VERSION = '1.14';
  my $EXPR = qr/ [a-z_][\w.]* /xs;
  my $LEFT = qr/
  	(?:
  		(?: (?:^|\n) [ \t]* )? \[\%\-
  		|
  		\[\% \+?
  	) \s*
  /xs;
  my $RIGHT  = qr/
  	\s* (?:
  		\+? \%\]
  		|
  		\-\%\] (?: [ \t]* \n )?
  	)
  /xs;
  my $PREPARSE = qr/
  	$LEFT ( IF | UNLESS | FOREACH ) \s+
  		(
  			(?: \S+ \s+ IN \s+ )?
  		\S+ )
  	$RIGHT
  	(?!
  		.*?
  		$LEFT (?: IF | UNLESS | FOREACH ) \b
  	)
  	( .*? )
  	(?:
  		$LEFT ELSE $RIGHT
  		(?!
  			.*?
  			$LEFT (?: IF | UNLESS | FOREACH ) \b
  		)
  		( .+? )
  	)?
  	$LEFT END $RIGHT
  /xs;
  my $CONDITION = qr/
  	\[\%\s
  		( ([IUF])\d+ ) \s+
  		(?:
  			([a-z]\w*) \s+ IN \s+
  		)?
  		( $EXPR )
  	\s\%\]
  	( .*? )
  	(?:
  		\[\%\s \1 \s\%\]
  		( .+? )
  	)?
  	\[\%\s \1 \s\%\]
  /xs;
  sub new {
  	bless { @_[1..$#_] }, $_[0];
  }
  sub preprocess {
  	my $self = shift;
  	my $text = shift;
  	$self->_preprocess(\$text);
  	return $text;
  }
  sub process {
  	my $self  = shift;
  	my $copy  = ${shift()};
  	my $stash = shift || {};
  	local $@  = '';
  	local $^W = 0;
  	$self->_preprocess( \$copy );
  	my $result = $self->_process( $stash, $copy );
  	if ( @_ ) {
  		${$_[0]} = $result;
  	} elsif ( defined wantarray ) {
  		require Carp;
  		Carp::carp('Returning of template results is deprecated in Template::Tiny 0.11');
  		return $result;
  	} else {
  		print $result;
  	}
  }
  sub _preprocess {
  	my $self = shift;
  	my $copy = shift;
  	my $id = 0;
  	1 while $$copy =~ s/
  		$PREPARSE
  	/
  		my $tag = substr($1, 0, 1) . ++$id;
  		"\[\% $tag $2 \%\]$3\[\% $tag \%\]"
  		. (defined($4) ? "$4\[\% $tag \%\]" : '');
  	/sex;
  }
  sub _process {
  	my ($self, $stash, $text) = @_;
  	$text =~ s/
  		$CONDITION
  	/
  		($2 eq 'F')
  			? $self->_foreach($stash, $3, $4, $5)
  			: eval {
  				$2 eq 'U'
  				xor
  				!! # Force boolification
  				$self->_expression($stash, $4)
  			}
  				? $self->_process($stash, $5)
  				: $self->_process($stash, $6)
  	/gsex;
  	$text =~ s/
  		$LEFT ( $EXPR ) $RIGHT
  	/
  		eval {
  			$self->_expression($stash, $1)
  			. '' # Force stringification
  		}
  	/gsex;
  	$text =~ s/^\s*(.+?)\s*\z/$1/s if $self->{TRIM};
  	return $text;
  }
  sub _foreach {
  	my ($self, $stash, $term, $expr, $text) = @_;
  	my $list = $self->_expression($stash, $expr);
  	unless ( ref $list eq 'ARRAY' ) {
  		return '';
  	}
  	return join '', map {
  		$self->_process( { %$stash, $term => $_ }, $text )
  	} @$list;
  }
  sub _expression {
  	my $cursor = $_[1];
  	my @path   = split /\./, $_[2];
  	foreach ( @path ) {
  		return undef if substr($_, 0, 1) eq '_';
  		my $type = ref $cursor;
  		if ( $type eq 'ARRAY' ) {
  			return '' unless /^(?:0|[0-9]\d*)\z/;
  			$cursor = $cursor->[$_];
  		} elsif ( $type eq 'HASH' ) {
  			$cursor = $cursor->{$_};
  		} elsif ( $type ) {
  			$cursor = $cursor->$_();
  		} else {
  			return '';
  		}
  	}
  	return $cursor;
  }
  1;
TEMPLATE_TINY

$fatpacked{"YAML/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TINY';
  use 5.008001; # sane UTF-8 support
  use strict;
  use warnings;
  package YAML::Tiny; # git description: v1.72-7-g8682f63
  our $VERSION = '1.73';
  use Exporter;
  our @ISA       = qw{ Exporter  };
  our @EXPORT    = qw{ Load Dump };
  our @EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };
  sub Dump {
      return YAML::Tiny->new(@_)->_dump_string;
  }
  sub Load {
      my $self = YAML::Tiny->_load_string(@_);
      if ( wantarray ) {
          return @$self;
      } else {
          return $self->[-1];
      }
  }
  BEGIN {
      *freeze = \&Dump;
      *thaw   = \&Load;
  }
  sub DumpFile {
      my $file = shift;
      return YAML::Tiny->new(@_)->_dump_file($file);
  }
  sub LoadFile {
      my $file = shift;
      my $self = YAML::Tiny->_load_file($file);
      if ( wantarray ) {
          return @$self;
      } else {
          return $self->[-1];
      }
  }
  sub new {
      my $class = shift;
      bless [ @_ ], $class;
  }
  sub read_string {
      my $self = shift;
      $self->_load_string(@_);
  }
  sub write_string {
      my $self = shift;
      $self->_dump_string(@_);
  }
  sub read {
      my $self = shift;
      $self->_load_file(@_);
  }
  sub write {
      my $self = shift;
      $self->_dump_file(@_);
  }
  my @UNPRINTABLE = qw(
      0    x01  x02  x03  x04  x05  x06  a
      b    t    n    v    f    r    x0E  x0F
      x10  x11  x12  x13  x14  x15  x16  x17
      x18  x19  x1A  e    x1C  x1D  x1E  x1F
  );
  my %UNESCAPES = (
      0 => "\x00", z => "\x00", N    => "\x85",
      a => "\x07", b => "\x08", t    => "\x09",
      n => "\x0a", v => "\x0b", f    => "\x0c",
      r => "\x0d", e => "\x1b", '\\' => '\\',
  );
  my %QUOTE = map { $_ => 1 } qw{
      null true false
  };
  my $re_capture_double_quoted = qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;
  my $re_capture_single_quoted = qr/\'([^\']*(?:\'\'[^\']*)*)\'/;
  my $re_capture_unquoted_key  = qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;
  my $re_trailing_comment      = qr/(?:\s+\#.*)?/;
  my $re_key_value_separator   = qr/\s*:(?:\s+(?:\#.*)?|$)/;
  sub _load_file {
      my $class = ref $_[0] ? ref shift : shift;
      my $file = shift or $class->_error( 'You did not specify a file name' );
      $class->_error( "File '$file' does not exist" )
          unless -e $file;
      $class->_error( "'$file' is a directory, not a file" )
          unless -f _;
      $class->_error( "Insufficient permissions to read '$file'" )
          unless -r _;
      open( my $fh, "<:unix:encoding(UTF-8)", $file );
      unless ( $fh ) {
          $class->_error("Failed to open file '$file': $!");
      }
      if ( _can_flock() ) {
          flock( $fh, Fcntl::LOCK_SH() )
              or warn "Couldn't lock '$file' for reading: $!";
      }
      my $contents = eval {
          use warnings FATAL => 'utf8';
          local $/;
          <$fh>
      };
      if ( my $err = $@ ) {
          $class->_error("Error reading from file '$file': $err");
      }
      unless ( close $fh ) {
          $class->_error("Failed to close file '$file': $!");
      }
      $class->_load_string( $contents );
  }
  sub _load_string {
      my $class  = ref $_[0] ? ref shift : shift;
      my $self   = bless [], $class;
      my $string = $_[0];
      eval {
          unless ( defined $string ) {
              die \"Did not provide a string to load";
          }
          if ( utf8::is_utf8($string) && ! utf8::valid($string) ) {
              die \<<'...';
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
          }
          utf8::upgrade($string);
          $string =~ s/^\x{FEFF}//;
          return $self unless length $string;
          my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
                  split /(?:\015{1,2}\012|\015|\012)/, $string;
          @lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;
          my $in_document = 0;
          while ( @lines ) {
              if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
                  shift @lines;
                  if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
                      push @$self,
                          $self->_load_scalar( "$1", [ undef ], \@lines );
                      next;
                  }
                  $in_document = 1;
              }
              if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
                  push @$self, undef;
                  while ( @lines and $lines[0] !~ /^---/ ) {
                      shift @lines;
                  }
                  $in_document = 0;
              } elsif ( ! $in_document && @$self ) {
                  die \"YAML::Tiny failed to classify the line '$lines[0]'";
              } elsif ( $lines[0] =~ /^\s*\-(?:\s|$|-+$)/ ) {
                  my $document = [ ];
                  push @$self, $document;
                  $self->_load_array( $document, [ 0 ], \@lines );
              } elsif ( $lines[0] =~ /^(\s*)\S/ ) {
                  my $document = { };
                  push @$self, $document;
                  $self->_load_hash( $document, [ length($1) ], \@lines );
              } else {
                  die \"YAML::Tiny failed to classify the line '$lines[0]'";
              }
          }
      };
      my $err = $@;
      if ( ref $err eq 'SCALAR' ) {
          $self->_error(${$err});
      } elsif ( $err ) {
          $self->_error($err);
      }
      return $self;
  }
  sub _unquote_single {
      my ($self, $string) = @_;
      return '' unless length $string;
      $string =~ s/\'\'/\'/g;
      return $string;
  }
  sub _unquote_double {
      my ($self, $string) = @_;
      return '' unless length $string;
      $string =~ s/\\"/"/g;
      $string =~
          s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;
      return $string;
  }
  sub _load_scalar {
      my ($self, $string, $indent, $lines) = @_;
      $string =~ s/\s*\z//;
      return undef if $string eq '~';
      if ( $string =~ /^$re_capture_single_quoted$re_trailing_comment\z/ ) {
          return $self->_unquote_single($1);
      }
      if ( $string =~ /^$re_capture_double_quoted$re_trailing_comment\z/ ) {
          return $self->_unquote_double($1);
      }
      if ( $string =~ /^[\'\"!&]/ ) {
          die \"YAML::Tiny does not support a feature in line '$string'";
      }
      return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
      return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;
      if ( $string !~ /^[>|]/ ) {
          die \"YAML::Tiny found illegal characters in plain scalar: '$string'"
              if $string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or
                  $string =~ /:(?:\s|$)/;
          $string =~ s/\s+#.*\z//;
          return $string;
      }
      die \"YAML::Tiny failed to find multi-line scalar content" unless @$lines;
      $lines->[0]   =~ /^(\s*)/;
      $indent->[-1] = length("$1");
      if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
          die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
      }
      my @multiline = ();
      while ( @$lines ) {
          $lines->[0] =~ /^(\s*)/;
          last unless length($1) >= $indent->[-1];
          push @multiline, substr(shift(@$lines), $indent->[-1]);
      }
      my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
      my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
      return join( $j, @multiline ) . $t;
  }
  sub _load_array {
      my ($self, $array, $indent, $lines) = @_;
      while ( @$lines ) {
          if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
              while ( @$lines and $lines->[0] !~ /^---/ ) {
                  shift @$lines;
              }
              return 1;
          }
          $lines->[0] =~ /^(\s*)/;
          if ( length($1) < $indent->[-1] ) {
              return 1;
          } elsif ( length($1) > $indent->[-1] ) {
              die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
          }
          if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
              my $indent2 = length("$1");
              $lines->[0] =~ s/-/ /;
              push @$array, { };
              $self->_load_hash( $array->[-1], [ @$indent, $indent2 ], $lines );
          } elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
              shift @$lines;
              unless ( @$lines ) {
                  push @$array, undef;
                  return 1;
              }
              if ( $lines->[0] =~ /^(\s*)\-/ ) {
                  my $indent2 = length("$1");
                  if ( $indent->[-1] == $indent2 ) {
                      push @$array, undef;
                  } else {
                      push @$array, [ ];
                      $self->_load_array(
                          $array->[-1], [ @$indent, $indent2 ], $lines
                      );
                  }
              } elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
                  push @$array, { };
                  $self->_load_hash(
                      $array->[-1], [ @$indent, length("$1") ], $lines
                  );
              } else {
                  die \"YAML::Tiny failed to classify line '$lines->[0]'";
              }
          } elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
              shift @$lines;
              push @$array, $self->_load_scalar(
                  "$2", [ @$indent, undef ], $lines
              );
          } elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
              return 1;
          } else {
              die \"YAML::Tiny failed to classify line '$lines->[0]'";
          }
      }
      return 1;
  }
  sub _load_hash {
      my ($self, $hash, $indent, $lines) = @_;
      while ( @$lines ) {
          if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
              while ( @$lines and $lines->[0] !~ /^---/ ) {
                  shift @$lines;
              }
              return 1;
          }
          $lines->[0] =~ /^(\s*)/;
          if ( length($1) < $indent->[-1] ) {
              return 1;
          } elsif ( length($1) > $indent->[-1] ) {
              die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
          }
          my $key;
          if ( $lines->[0] =~
              s/^\s*$re_capture_single_quoted$re_key_value_separator//
          ) {
              $key = $self->_unquote_single($1);
          }
          elsif ( $lines->[0] =~
              s/^\s*$re_capture_double_quoted$re_key_value_separator//
          ) {
              $key = $self->_unquote_double($1);
          }
          elsif ( $lines->[0] =~
              s/^\s*$re_capture_unquoted_key$re_key_value_separator//
          ) {
              $key = $1;
              $key =~ s/\s+$//;
          }
          elsif ( $lines->[0] =~ /^\s*\?/ ) {
              die \"YAML::Tiny does not support a feature in line '$lines->[0]'";
          }
          else {
              die \"YAML::Tiny failed to classify line '$lines->[0]'";
          }
          if ( exists $hash->{$key} ) {
              warn "YAML::Tiny found a duplicate key '$key' in line '$lines->[0]'";
          }
          if ( length $lines->[0] ) {
              $hash->{$key} = $self->_load_scalar(
                  shift(@$lines), [ @$indent, undef ], $lines
              );
          } else {
              shift @$lines;
              unless ( @$lines ) {
                  $hash->{$key} = undef;
                  return 1;
              }
              if ( $lines->[0] =~ /^(\s*)-/ ) {
                  $hash->{$key} = [];
                  $self->_load_array(
                      $hash->{$key}, [ @$indent, length($1) ], $lines
                  );
              } elsif ( $lines->[0] =~ /^(\s*)./ ) {
                  my $indent2 = length("$1");
                  if ( $indent->[-1] >= $indent2 ) {
                      $hash->{$key} = undef;
                  } else {
                      $hash->{$key} = {};
                      $self->_load_hash(
                          $hash->{$key}, [ @$indent, length($1) ], $lines
                      );
                  }
              }
          }
      }
      return 1;
  }
  sub _dump_file {
      my $self = shift;
      require Fcntl;
      my $file = shift or $self->_error( 'You did not specify a file name' );
      my $fh;
      if ( _can_flock() ) {
          my $flags = Fcntl::O_WRONLY()|Fcntl::O_CREAT();
          sysopen( $fh, $file, $flags )
              or $self->_error("Failed to open file '$file' for writing: $!");
          binmode( $fh, ":raw:encoding(UTF-8)");
          flock( $fh, Fcntl::LOCK_EX() )
              or warn "Couldn't lock '$file' for reading: $!";
          truncate $fh, 0;
          seek $fh, 0, 0;
      }
      else {
          open $fh, ">:unix:encoding(UTF-8)", $file;
      }
      print {$fh} $self->_dump_string;
      unless ( close $fh ) {
          $self->_error("Failed to close file '$file': $!");
      }
      return 1;
  }
  sub _dump_string {
      my $self = shift;
      return '' unless ref $self && @$self;
      my $indent = 0;
      my @lines  = ();
      eval {
          foreach my $cursor ( @$self ) {
              push @lines, '---';
              if ( ! defined $cursor ) {
              } elsif ( ! ref $cursor ) {
                  $lines[-1] .= ' ' . $self->_dump_scalar( $cursor );
              } elsif ( ref $cursor eq 'ARRAY' ) {
                  unless ( @$cursor ) {
                      $lines[-1] .= ' []';
                      next;
                  }
                  push @lines, $self->_dump_array( $cursor, $indent, {} );
              } elsif ( ref $cursor eq 'HASH' ) {
                  unless ( %$cursor ) {
                      $lines[-1] .= ' {}';
                      next;
                  }
                  push @lines, $self->_dump_hash( $cursor, $indent, {} );
              } else {
                  die \("Cannot serialize " . ref($cursor));
              }
          }
      };
      if ( ref $@ eq 'SCALAR' ) {
          $self->_error(${$@});
      } elsif ( $@ ) {
          $self->_error($@);
      }
      join '', map { "$_\n" } @lines;
  }
  sub _has_internal_string_value {
      my $value = shift;
      my $b_obj = B::svref_2object(\$value);  # for round trip problem
      return $b_obj->FLAGS & B::SVf_POK();
  }
  sub _dump_scalar {
      my $string = $_[1];
      my $is_key = $_[2];
      my $has_string_flag = _has_internal_string_value($string);
      return '~'  unless defined $string;
      return "''" unless length  $string;
      if (Scalar::Util::looks_like_number($string)) {
          if ( $is_key || $has_string_flag ) {
              return qq['$string'];
          }
          else {
              return $string;
          }
      }
      if ( $string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/ ) {
          $string =~ s/\\/\\\\/g;
          $string =~ s/"/\\"/g;
          $string =~ s/\n/\\n/g;
          $string =~ s/[\x85]/\\N/g;
          $string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
          $string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;
          return qq|"$string"|;
      }
      if ( $string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or
          $QUOTE{$string}
      ) {
          return "'$string'";
      }
      return $string;
  }
  sub _dump_array {
      my ($self, $array, $indent, $seen) = @_;
      if ( $seen->{refaddr($array)}++ ) {
          die \"YAML::Tiny does not support circular references";
      }
      my @lines  = ();
      foreach my $el ( @$array ) {
          my $line = ('  ' x $indent) . '-';
          my $type = ref $el;
          if ( ! $type ) {
              $line .= ' ' . $self->_dump_scalar( $el );
              push @lines, $line;
          } elsif ( $type eq 'ARRAY' ) {
              if ( @$el ) {
                  push @lines, $line;
                  push @lines, $self->_dump_array( $el, $indent + 1, $seen );
              } else {
                  $line .= ' []';
                  push @lines, $line;
              }
          } elsif ( $type eq 'HASH' ) {
              if ( keys %$el ) {
                  push @lines, $line;
                  push @lines, $self->_dump_hash( $el, $indent + 1, $seen );
              } else {
                  $line .= ' {}';
                  push @lines, $line;
              }
          } else {
              die \"YAML::Tiny does not support $type references";
          }
      }
      @lines;
  }
  sub _dump_hash {
      my ($self, $hash, $indent, $seen) = @_;
      if ( $seen->{refaddr($hash)}++ ) {
          die \"YAML::Tiny does not support circular references";
      }
      my @lines  = ();
      foreach my $name ( sort keys %$hash ) {
          my $el   = $hash->{$name};
          my $line = ('  ' x $indent) . $self->_dump_scalar($name, 1) . ":";
          my $type = ref $el;
          if ( ! $type ) {
              $line .= ' ' . $self->_dump_scalar( $el );
              push @lines, $line;
          } elsif ( $type eq 'ARRAY' ) {
              if ( @$el ) {
                  push @lines, $line;
                  push @lines, $self->_dump_array( $el, $indent + 1, $seen );
              } else {
                  $line .= ' []';
                  push @lines, $line;
              }
          } elsif ( $type eq 'HASH' ) {
              if ( keys %$el ) {
                  push @lines, $line;
                  push @lines, $self->_dump_hash( $el, $indent + 1, $seen );
              } else {
                  $line .= ' {}';
                  push @lines, $line;
              }
          } else {
              die \"YAML::Tiny does not support $type references";
          }
      }
      @lines;
  }
  our $errstr    = '';
  sub _error {
      require Carp;
      $errstr = $_[1];
      $errstr =~ s/ at \S+ line \d+.*//;
      Carp::croak( $errstr );
  }
  my $errstr_warned;
  sub errstr {
      require Carp;
      Carp::carp( "YAML::Tiny->errstr and \$YAML::Tiny::errstr is deprecated" )
          unless $errstr_warned++;
      $errstr;
  }
  use B;
  my $HAS_FLOCK;
  sub _can_flock {
      if ( defined $HAS_FLOCK ) {
          return $HAS_FLOCK;
      }
      else {
          require Config;
          my $c = \%Config::Config;
          $HAS_FLOCK = grep { $c->{$_} } qw/d_flock d_fcntl_can_lock d_lockf/;
          require Fcntl if $HAS_FLOCK;
          return $HAS_FLOCK;
      }
  }
  use Scalar::Util ();
  BEGIN {
      local $@;
      if ( eval { Scalar::Util->VERSION(1.18); } ) {
          *refaddr = *Scalar::Util::refaddr;
      }
      else {
          eval <<'END_PERL';
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
      }
  }
  delete $YAML::Tiny::{refaddr};
  1;
YAML_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use 5.020;
use strict;
use warnings;

use File::Temp qw();
use File::Copy qw(move);
use File::Slurp qw(read_file write_file);
use File::Spec::Functions qw(catfile);
use File::Path qw(make_path);
use File::Basename qw(basename dirname);

use JSON::Tiny qw(encode_json decode_json); # HTTP responses, docker + nimbus config
use YAML::Tiny;     # Docker compose
use HTTP::Tiny;     # Download update, tags
use Template::Tiny; # Text content

use Getopt::Long;
use Time::Piece;
use Sort::Versions;
use Term::ANSIColor qw(:constants color); # Steffensen to allow color text
# use Term::ANSIColor;

use if $^O eq 'MSWin32',   'Win32::Console::ANSI';
use if $^O eq 'MSWin32', qw'Win32::ShellQuote quote_system';

no if $] < 5.024, qw( warnings experimental::postderef );
use feature 'postderef';

no if $] < 5.026, qw( warnings experimental::lexical_subs );
use feature 'lexical_subs';

no warnings 'experimental::signatures';
use feature 'signatures';

use constant {
    RELEASE_VERSION => "1.6.3_ms",
    RELEASE_DATE    => "2022-09-01",
    COMPOSE_FILE    => 'docker-compose.yml',
    DEFAULT_TAG_COUNT => 10
};

my %config = do {
    my $isWin32 = $^O eq 'MSWin32';
    my $userHome = $ENV{HOME} // $ENV{USERPROFILE};
    my $nimbusHome = $ENV{NIMBUS_HOME} // $ENV{NIMBUS_BASEDIR} //
        catfile( 
            $userHome // fatal("Could not determine home directory.\n"), 
            ".nimbusapp" 
        );

    make_path($nimbusHome) unless -d $nimbusHome;

    (
        WINDOWS => $isWin32,
        DEFAULT_ORG => $ENV{NIMBUS_DEFAULT_ORG} // "admpresales",
        APPS_CONFIG => $ENV{NIMBUS_CONFIG} // catfile($nimbusHome, 'apps.json'),
        APPS_OLD_CONFIG => $ENV{NIMBUS_OLD_CONFIG} // catfile($nimbusHome, 'apps.config'),
        CACHE => $ENV{NIMBUS_CACHE} // catfile($nimbusHome, 'cache'),
        DEBUG => $ENV{NIMBUS_DEBUG} // 0,     # Be verbose
        FORCE => $ENV{NIMBUS_FORCE} // 0,     # Skip prompts
        QUIET => $ENV{NIMBUS_QUIET} // 0,     # Be quiet
        DAEMON_CONFIG => $isWin32 ? 'C:\ProgramData\Docker\config\daemon.json' : '/etc/docker/daemon.json',
        LOG_FILE => $ENV{NIMBUS_LOG} // catfile($nimbusHome, 'nimbusapp.log'),
        INSTALL => $ENV{NIMBUS_INSTALL_DIR} // dirname($0),
        DOWNLOAD => $ENV{NIMBUS_DOWNLOAD_URL} // 'https://github.com/admpresales/nimbusapp/releases/latest/download/nimbusapp' . ($isWin32 ? '.zip' : '.tar.gz'),
        HUB_API_BASE => $ENV{NIMBUS_HUB_API_BASE} // "https://hub.docker.com/v2",
        INTELLIJ_MOUNT_HOME => $ENV{NIMBUS_INTELLIJ_HOME} // catfile( $userHome, 'IdeaProjects_docker' ),
        INTELLIJ_MOUNT_M2   => $ENV{NIMBUS_INTELLIJ_MAVEN} // catfile( $userHome, '.m2' ),
        NL => $isWin32 ? "\n" : "\n"
    );
};
# Steffensen change NL above - had to remove \r - not sure why

my %dispatch = (
    help => sub { usage(); },
    version => \&display_version,
    update => sub {
        display_version(); 
        prompt('CONFIRM_UPDATE');
        update_version();
    },
    up => prompt_first('CONFIRM_RECREATE', \&docker_app_compose),
    down => prompt_first('CONFIRM_DELETE', \&docker_compose),
    purge => prompt_first('CONFIRM_PURGE', \&docker_compose),
    downup => prompt_first('CONFIRM_DOWNUP', \&docker_du_compose),
    bounce => prompt_first('CONFIRM_DOWNUP', \&docker_du_compose),
    render => \&docker_app,
    inspect => \&docker_app,
    tags => \&list_tags
);

$dispatch{$_} = \&docker_compose for qw( pull start stop restart rm ps logs exec );

# Output functions
# Everything except docker-{compose,app} output goes to STDERR
#    This allows that output to be easily recorded or used in scripts
use subs qw(info debug warning error fatal usage);

sub _log {
    return if $ENV{NIMBUS_INTERNAL};
    my $logLevel = shift;
    my $t = localtime;
    open(my $fh, '>>', $config{LOG_FILE});
    printf $fh "%s %6s %s%s", $t->datetime, $logLevel, join('', @_), $config{NL};
    close($fh);
}

sub _output { print STDERR @_, $config{NL} unless $ENV{NIMBUS_INTERNAL}; }

sub debug   { _log 'DEBUG', @_; _output @_ if $config{DEBUG}; }
sub info    { _log  'INFO', @_; _output @_ unless $config{QUIET}; }
sub warning { _log  'WARN', @_; _output text_block('LABEL_WARN'), @_; }
sub error   { _log 'ERROR', @_; _output text_block('LABEL_ERROR'), @_; }
sub fatal   { _log 'FATAL', @_; _output text_block('LABEL_ERROR'), @_; exit 1; }
sub usage   { _log 'FATAL', @_; _output @_ ? (text_block('LABEL_ERROR'), @_, $config{NL}) : '', text_block('USAGE'); exit 1; }

# Load some text from the configuration document at the bottom of this file
# This keeps huge blocks of text out of the code, which may or may not be useful
#
# As this sub is used to handle error text, any errors should result in a 'die'
#   instead of using the program's standard 'fatal'
sub text_block($name, $params = {}) {
    state $text = load_text();
    state $template = Template::Tiny->new();
    state $formatting = {
        red => color('bold red'),
        yellow => color('bold yellow'),
        bold => color('bold'),
        reset => color('reset')
    };

    die "Unknown message template: ${name}.\n" unless $text->{$name};

    $params->@{keys %$formatting} = values %$formatting;

    $template->process(\$text->{$name}, $params, \my $output) || die sprintf "Template error (%s): %s\n", $name, $template->error;

    return $output;
}

sub download($url, $context = 'Download error') {
    my $res = HTTP::Tiny->new->get($url);

    if (! $res->{success}) {
        fatal $context, $config{NL},
              "\t", join("\t", $url, $res->{status}, $res->{reason})
    }
    
    $res->{content};
}

sub display_version {
    info("Release Version: ", RELEASE_VERSION);
    info("Release Date: ", RELEASE_DATE);
    0;
}

sub update_version {
    my $archive = do {
        my $content = download $config{DOWNLOAD};
        
        my $temp = File::Temp->new(UNLINK => 0, suffix => $config{WINDOWS} ? '.zip' : '.tar.gz');
        print $temp $content;
        close($temp);

        $temp->filename;
    };

    debug("Temporary download location: ", $archive);
    debug("Extracting to: ", $config{INSTALL});
    my $nimbus_exe = catfile($config{INSTALL}, 'nimbusapp');

    my @extract = $config{WINDOWS}
            ?  quote_system('powershell', '-c', qq(Expand-Archive -Force -Path "$archive" -DestinationPath "$config{INSTALL}"))
            : ( (! -w $nimbus_exe || ! -w $config{INSTALL} ? 'sudo' : ()), 'tar', 'xzf', $archive, '--no-same-owner', '-C', $config{INSTALL} );

    debug("Running: @extract");
    system(@extract);

    fatal "Failed to extract '$archive'. Status: $?" if $?;

    unlink($archive) if -f $archive;

    my @version = ($nimbus_exe, '--version');
    debug("Running: @version");
    system(@version);
}

sub prompt($label, $params = {}) {
    return if $config{FORCE} || $params->{cmd} && $params->{args} && $params->{cmd} eq 'up' && grep { /--force-recreate/ } $params->{args}->@*;

    print STDERR text_block($label, $params) =~ s/[\n\r]+$//r, " [y/N] ";

    my $result = <STDIN>;
    chomp($result);

    _log 'PROMPT', $label, " = ", $result;

    exit if $result !~ /^y(es)?$/i;
}

sub prompt_first($label, $sub) {
    return sub {
        my $params = $_[1];

        if (nimbusapp($params, 'ps -q')) {
            local $params->{containers} = [ nimbusapp($params, 'ps --service --all') ];
            prompt($label, $params);
        }

        $sub->(@_);        
    };
}

sub nimbusapp($params, @args) {
    my @result = do {
        local $ENV{NIMBUS_INTERNAL} = 1; # Prevent recursive logging
        my $a = join ' ', @args;
        qx{perl "$0" "$params->{originalImage}" -q $a}
    };

    if (wantarray) {
        chomp @result;
        return @result;
    }
    else {
        return join '', @result;
    }
}

sub apply_mounts($params) {
    return unless $params->{intellij_home} || $params->{intellij_m2};
    fatal "Mounts are currently only available for Intellij" unless $params->{image} eq 'intellij';
    
    my $compose = YAML::Tiny->read( $params->{composeFile} );

    if ($params->{intellij_home}) {
        push $compose->[0]->{services}->{intellij}->{volumes}->@*,
            {
                type => 'bind',
                source => $config{INTELLIJ_MOUNT_HOME},
                target => '/home/demo/IdeaProjects'
            };
    }

    if ($params->{intellij_m2}) {
        push $compose->[0]->{services}->{intellij}->{volumes}->@*,
            {
                type => 'bind',
                source => $config{INTELLIJ_MOUNT_M2},
                target => '/home/demo/.m2'
            };
    }

    my $yaml = $compose->write_string( $params->{composeFile} );
    $yaml =~ s/'(true|false|null)'/$1/g;

    write_file( $params->{composeFile}, $yaml );
}

sub docker_app($cmd, $params, $args) {
    if ($cmd eq 'inspect') {
        my @command = ('docker-app', 'inspect', $params->{fullImage});
        debug("Running: ", join ' ', @command);
        system(@command) or exit $?;
    }
    else { # Render
        my @settings = map { 
            ('-s', sprintf '%s="%s"', $_, $params->{set}{$_})
        } keys $params->{set}->%*;
        
        make_path($params->{composeDir}) unless -d $params->{composeDir};

        my $temp = File::Temp->new(UNLINK => 0);

        my @command = ('docker-app', 'render', @settings, $params->{fullImage});
        @command = quote_system(@command) if $config{WINDOWS};
        debug("Running: ", join ' ', @command);
        open(my $app, '-|', @command) or fatal "Could not run docker-app: $! ($?)";

        while (defined(my $line = <$app>)) {
            print $temp $line;
        }

        close($app);     my $rc = $? >> 8;
        close($temp);

        if ($rc) {
            unlink($temp->filename);
            if ($params->{tag} =~ /^(.*?)_/) {
                warning "Image name contains an underscore which is not used by nimbusapp. ",
                      sprintf "Try using %s/%s:%s instead.", $params->{org}, $params->{image}, $1;
            }
            fatal "Could not render."
        }

        move $temp->filename, $params->{composeFile} or fatal "Error moving compose file: $!";
        apply_mounts($params);

        if ($cmd eq 'render') {
            print read_file $params->{composeFile};
        }
    }

    return 0;
}

sub docker_compose($cmd, $params, $args) {
# Steffensen change - added this if statement to stop LR agent process for start or up - WINDOWS ONLY

    if ($^O eq "MSWin32" && ($cmd eq 'start' || $cmd eq 'up')) {
    	use Sys::Hostname;
    	my $execpath = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
	my $servicename = "\\\"LoadRunner\ Data\ Service\\\"";
    	my $hostname = hostname();
    	if ( $hostname eq "nimbusclient" ) { # only do this if on nimbusclient
    		print "Stopping LR Agent  ..." ;
    		system "taskkill /IM magentproc.exe /F >nul 2>&1";
			system "$execpath Stop-Service $servicename";
    		print GREEN " done\n", RESET;
    		# print " done\n";
    	}
    }

    if (! -f $params->{composeFile}) {
        my $oldComposeFile = catfile($config{CACHE}, $params->@{qw(project org image tag)}, $params->{image} . '.yml');

        if (-f $oldComposeFile 
            && move($oldComposeFile, $params->{composeFile})) {
            
            info "Importing configuration from previous version of nimbusapp";
        }
        else {
            if ($!) {
                warning "Error importing old config: $!";
            }

            my $rc = docker_app($cmd, $params, $args);
            return $rc if $rc;
        }
    }
    
    if ($cmd eq 'up') {
        # Start in background by default (exclusive with --no-start)
        unshift @$args, '-d' unless grep { $_ eq '--no-start' || $_ eq '-d' } @$args;

        # Re-initialize anonymous volumes
        unshift @$args, '-V' unless $params->{preserve_volumes} || grep { $_ eq '-V' } @$args;

        # Remove orphan containers
        unshift @$args, '--remove-orphans' unless grep { $_ eq '--remove-orphans' } @$args;
    }

    if ($cmd eq 'down') {

        # Remove named and anonymous volumes with the container
        unshift @$args, '-v' unless $params->{preserve_volumes} || grep { $_ eq '-v' } @$args;

        # Remove orphan containers
        unshift @$args, '--remove-orphans' unless grep { $_ eq '--remove-orphans' } @$args;
    }

    if ($cmd eq 'purge') {

        $cmd = 'down'; # change docker compose command to down - there is no purge in docker

        # Remove named and anonymous volumes with the container
        unshift @$args, '-v' unless $params->{preserve_volumes} || grep { $_ eq '-v' } @$args;

        # Remove orphan containers
        unshift @$args, '--remove-orphans' unless grep { $_ eq '--remove-orphans' } @$args;

        # Remove images if purge was the command
        unshift @$args, '--rmi', 'all' unless grep { $_ eq '--rmi all'} @$args;
    }

    my @compose = ( 'docker-compose', '-f', $params->{composeFile}, '-p', $params->{project}, $cmd, @$args );
    @compose = quote_system(@compose) if $config{WINDOWS};
    
    #print "COMPOSE = @compose\n";

    debug("Running: ", join ' ', @compose);
    system @compose;

    # Steffensen change - added this if statement to start LR agent process for stop or down - WINDOWWS ONLY
    # Must start LR Agent only after all containers are stopped
    if ($^O eq "MSWin32" && ($cmd eq 'stop' || $cmd eq 'down')) {
	use Sys::Hostname;
	my $execpath = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
	my $servicename = "\\\"LoadRunner\ Data\ Service\\\"";
	my $hostname = hostname();
	if ( $hostname eq "nimbusclient" ) { # only do this if on nimbusclient
		print "Starting LR Agent  ..." ;
		system 1, "C:\\Program Files (x86)\\Micro Focus\\LoadRunner\\launch_service\\bin\\magentproc.exe";
		system "$execpath Start-Service $servicename";
		print GREEN " done\n", RESET;
		# print " done\n";
	}
    }

    return 0;
}

sub docker_du_compose($cmd, $params, $args) {

    if (! -f $params->{composeFile}) {
        my $oldComposeFile = catfile($config{CACHE}, $params->@{qw(project org image tag)}, $params->{image} . '.yml');

        if (-f $oldComposeFile 
            && move($oldComposeFile, $params->{composeFile})) {
            
            info "Importing configuration from previous version of nimbusapp";
        }
        else {
            if ($!) {
                warning "Error importing old config: $!";
            }

            my $rc = docker_app($cmd, $params, $args);
            return $rc if $rc;
        }
    }

    if ($cmd eq 'downup' || $cmd eq 'bounce') {

        $cmd = 'down';
        unshift @$args, '-v' unless $params->{preserve_volumes} || grep { $_ eq '-v' } @$args;
        unshift @$args, '--remove-orphans' unless grep { $_ eq '--remove-orphans' } @$args;
        my @compose = ( 'docker-compose', '-f', $params->{composeFile}, '-p', $params->{project}, $cmd, @$args );
        @compose = quote_system(@compose) if $config{WINDOWS};
        #print "COMPOSE = @compose\n";
        debug("Running: ", join ' ', @compose);
        system @compose;

        $cmd = 'up';
        if ($params->{preserve_volumes} || grep { $_ eq '--remove-orphans'} @$args) {
            shift @$args;
        }
        if (grep { $_ eq '-v'} @$args) {
            shift @$args;
        }
        unshift @$args, '-d' unless grep { $_ eq '--no-start' || $_ eq '-d' } @$args;
        unshift @$args, '-V' unless $params->{preserve_volumes} || grep { $_ eq '-V' } @$args;
        unshift @$args, '--remove-orphans' unless grep { $_ eq '--remove-orphans' } @$args;
        @compose = ( 'docker-compose', '-f', $params->{composeFile}, '-p', $params->{project}, $cmd, @$args );
        @compose = quote_system(@compose) if $config{WINDOWS};
        #print "COMPOSE = @compose\n";
        debug("Running: ", join ' ', @compose);
        system @compose;

    }

    return 0;
}

sub docker_app_compose {
    my $rc = docker_app(@_);
    return $rc if $rc;
    return docker_compose(@_);
}

sub list_tags($, $params, $) {
    my $url = sprintf("%s/repositories/%s/%s.dockerapp/tags", $config{HUB_API_BASE}, $params->{org}, $params->{originalImage});
    my $n = $params->{latest} // $params->{number} // DEFAULT_TAG_COUNT;

    my $data = decode_json(download $url)->{results};

    print "$_", $config{NL} for
        grep { $n-- > 0 }
        sort { versioncmp($b, $a) }
        map { $_->{name} }
        grep { $_->{name} !~ /-dev$/ } @$data;
}

sub read_app_config_json {
    if (-f $config{APPS_CONFIG}) {
        return decode_json(scalar read_file( $config{APPS_CONFIG} ));
    }

    return undef;
}

sub read_app_config_old {
    return undef unless -f $config{APPS_OLD_CONFIG};

    return {
        map {
            my %app;
            @app{qw(org image tag)} = $_->@[1..3];
            $_->[0] => \%app;
        }
        grep { @$_ == 4 }
        map { [ split qr/[\s:\/]/ ] }
        read_file( $config{APPS_OLD_CONFIG} )
    };
}

sub read_app_config {
    if (-f $config{APPS_CONFIG}) {
        read_app_config_json
    }
    elsif (-f $config{APPS_OLD_CONFIG}) {
        read_app_config_old
    }
    else {
        {};
    }
}

sub load_app_config(%params) {
    my $apps = read_app_config;

    if (defined(my $app = $apps->{$params{project}})) {
        $params{$_} ||= $app->{$_} for qw(image tag org);
        $params{image} = $app->{image} if $params{project} eq $params{image};
    }

    return %params;
}

sub save_app_config(%params) {
    my $apps = read_app_config;

    $apps->{$params{project}} = {
        map { $_ => $params{$_} } qw(image org tag)
    };

    write_file $config{APPS_CONFIG}, encode_json($apps);
}

sub get_dns_servers {
    grep { state %seen; !$seen{$_}++ } map { /DNS.*?:\s*(\d.*)/ } qx{netsh interface ip show config};
}

# States:
#   1  STOPPED
#   4  RUNNING
sub wait_for_docker($state) {
    while (1) {
        qx{sc.exe query docker} =~ /^\s* STATE \s* : \s* \d+ \s* (\w+)/imx;
        last if $1 eq $state;
        sleep 1;
    }
}

sub restart_docker {
    qx{sc.exe stop docker};
    wait_for_docker('STOPPED');
    qx{sc.exe start docker};
    wait_for_docker('RUNNING');
}

# Ensure docker networking is set up
# { "dns": [ "192.168.61.2" ] }
if ($config{WINDOWS}) {
    my $daemon = -f $config{DAEMON_CONFIG} ? decode_json( scalar read_file($config{DAEMON_CONFIG}) ) : {};

    if (!defined $daemon->{dns} || @{$daemon->{dns}} == 0) {
        info text_block('DNS_START', {});
        my @dns = get_dns_servers();

        if (@dns) {
            $daemon->{dns} = [ @dns ];
            write_file( $config{DAEMON_CONFIG}, encode_json($daemon) );
            info text_block('DNS_COMPLETE', { servers => [ @dns ], file => $config{DAEMON_CONFIG} });
            restart_docker();
        } else {
            warning text_block('MISSING_DNS', { file => $config{DAEMON_CONFIG} });
        }
    }
}

my $image_re = qr{
    ^(?:  (?<org>   [a-z0-9]{4,30}  ) \/ )?             # Optional org  (lowercase + numbers)
          (?<image> [a-z0-9][a-z0-9_.-]+ )              # Image         (lowercase + numbers + limited special)
     (?: :(?<tag>   [a-zA-Z0-9][a-zA-Z0-9_.-]+ ) )? $   # Optional tag  (lower/upper + numbers + limited special)
}xx;

my %params = (
    debug => \$config{DEBUG},
    force => \$config{FORCE},
    quiet => \$config{QUIET},
    org => $config{DEFAULT_ORG},
    set => {}
);

usage unless @ARGV;
_log 'CMD', join(' ', @ARGV);

my $command;
{
    local $SIG{__WARN__} = \&usage;
    my sub dispatch_exit { exit ($dispatch{$_[0]}->(@_) // 0); }

    GetOptions( \%params, 
        'project|p=s',
        'intellij_home|v', 'intellij_m2|m', 'preserve_volumes',
        'debug|d', 'quiet|q', 'force|f',
        'number|n=i', 'latest',
        'set|s=s%',
        ( map { $_ => \&dispatch_exit } qw(help update version) ),
        '<>' => sub {
            state $image;
            if (!defined $image) {
                $image = shift;

                if ($image =~ /^(help|version|update)$/) {
                    dispatch_exit($1);
                }
                elsif ($image =~ $image_re) {
                    @params{keys %+} = values %+;
                }
                else {
                    usage "Invalid image format: $image";
                }
            }
            else {
                $command = shift;
                unshift @ARGV, '--'; # die('!FINISH');
            }
        }
    ) or usage "Error parsing command line options options.";
}

if (not defined $params{project}) {
    if (not defined $params{image}) {
        usage("No image or project specified.");
    }

    $params{project} = $params{image};
}

$params{originalImage} = $params{image};

%params = load_app_config(%params);

usage("No image found.") if not defined $params{image};
$params{originalImage} ||= $params{image};
$params{composeDir} = catfile($config{CACHE}, $params{project});
$params{composeFile} = catfile($params{composeDir}, COMPOSE_FILE);
$params{cmd} = $command;
$params{args} = [ @ARGV ];


# Steffensen code to allow latest tag - easy!
if (defined $params{tag} && $params{tag} eq 'latest') {
        $params{tag} = nimbusapp(\%params, '--latest tags');
        chomp $params{tag};
}

if (!defined $command) {
    usage "Please specify a command.";
}
elsif (!defined $dispatch{$command}) {
    usage "Unknown command: $command";
}
elsif ($command ne 'tags') {
    fatal text_block('MISSING_VERSION', \%params) if not defined $params{tag};

    $params{fullImage} = sprintf "%s/%s.dockerapp:%s", @params{qw(org image tag)};
    info 'Using: ', $params{fullImage};
}

my $rc = $dispatch{$command}->($command, \%params, \@ARGV);
save_app_config(%params) if $rc == 0;
exit $rc;


sub load_text {
return {
LABEL_WARN => '[% yellow %]WARNING:[% reset %] ',
LABEL_ERROR => '[% red %]ERROR:[% reset %] ',

DNS_START => 'No Docker DNS configuration found, attempting to configure DNS servers.',

DNS_COMPLETE => q{
Docker DNS servers have been configured to use the following addresses:
[% FOREACH server IN servers %]
    [% server %]
[% END %]

Docker DNS settings can be reviewed in [% file %]
},

MISSING_DNS => q{No DNS servers found, Docker containers may not be able to communicate with other servers.
Docker DNS settings can be found in [% file %]
},

MISSING_VERSION => q{No version number specified!

If this is your first time using [% originalImage %], please specify a version number:

nimbusapp [% originalImage %]:<version_number> [% cmd %]

The version number you choose will be remembered for future commands.
},

CONFIRM_PURGE => q{
[% bold %]This action will [% red %]PURGE[% reset %][% bold %] your containers and images and is [% red %]IRREVERSIBLE[% reset %]!

[% bold %]You may wish to use [% reset %]`nimbusapp [% originalImage %] stop'[% bold %] to shut down your containers without deleting them[% reset %]
    
[% bold %]The following container(s) and their image(s) will be deleted:[% reset %]
[% FOREACH item IN containers -%]
    - [% item %]
[% END -%]

[% red %]Do you wish to PURGE these containeri(s) and their image(s)?[% reset %]
},

CONFIRM_DOWNUP => q{
[% bold %]This action will [% red %]DOWN-UP[% reset %] or [% red %]BOUNCE[% reset %][% bold %] your containers and is [% red %]IRREVERSIBLE[% reset %]!

[% bold %]You may wish to use [% reset %]`nimbusapp [% originalImage %] down'[% bold %] to remove your containers without deleting the imagesm[% reset %]
    
[% bold %]The following container(s) and their image(s) will be bounced (down'd and up'd):[% reset %]
[% FOREACH item IN containers -%]
    - [% item %]
[% END -%]

[% red %]Do you wish to DOWNUP/BOUNCE these containeri(s) and their image(s)?[% reset %]
},

CONFIRM_UPDATE => '[% red %]Do you want to update your nimbusapp version?[% reset %]',

CONFIRM_DELETE => q{
[% bold %]This action will [% red %]DELETE[% reset %][% bold %] your container(s) and is [% red %]IRREVERSIBLE[% reset %]!

[% bold %]You may wish to use [% reset %]`nimbusapp [% originalImage %] stop'[% bold %] to shut down your containers without deleting them[% reset %]
    
[% bold %]The following container(s) will be deleted:[% reset %]
[% FOREACH item IN containers -%]
    - [% item %]
[% END -%]

[% red %]Do you wish to DELETE these containers?[% reset %]
},

CONFIRM_RECREATE => q{
[% bold %]This action may cause one or more of your containers to be [% red %]DELETED[% reset %][% bold %] and [% red %]RECREATED[% reset %].

[% bold %]Recreating containers is normal when changing their configuration, such as image, tag or ports.[% reset %]

[% bold %]You may wish to use [% reset %]`nimbusapp [% originalImage %] start'[% bold %] to start your existing containers.[% reset %]

[% bold %]The following containers may be recreated:[% reset %]
[% FOREACH item IN containers -%]
    - [% item %]
[% END -%]

[% red %]Some or all containers may be recreated, do you wish to continue?[% reset %]
},

USAGE => q{
Usage: nimbusapp <IMAGE>[:<VERSION>/latest] [OPTIONS] COMMAND [CMD OPTIONS]

Options:
    IMAGE       The Docker App file you wish to run. If no repository is provided, admpresales is assumed.
    VERSION     The version of the Docker App file you wish to run.
                Only required the first time a container is created, and will be cached for future use.
    latest      When supplied as the version, the value from "nimbusapp <IMAGE> --latest tags" is substituted.
    -d, --debug Enable debugging output (use twice for verbose bash commands)
    -f, --force Skip all prompts - Use with caution, this option will happily delete your data without warning
    -s, --set   Enables you to set(override) default arguments
    --version   Print the version of nimbusapp and exit

Commands:
    down     Stop and remove containers
    downup   Stop and remove containers and then run 'up' to get original containers state
    bounce   Stop and remove containers and then run 'up' to get original containers state
    purge    Stop and remove containers and images
    help     Prints this help message
    inspect  Shows metadata and settings for a given application
    logs     Shows logs for containers
    ps       Lists containers
    pull     Pull service images
    render   Render the Compose file for the application
    rm       Remove stopped containers
    restart  Restart containers
    start    Start existing containers
    stop     Stop existing containers
    up       Creates and start containers
    version  Prints version information

Command Options:
    up  --no-start       Create containers without starting them
        --force-recreate Force all containers to be re-created
        --no-recreate    Do not allow any containers to be re-created
}
}
}
